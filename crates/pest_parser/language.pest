program = _{ SOI ~ expression* ~ EOI }

expression = _{
    import
  | number
  | block
  | string
  | macro
  | export
  | enum
  | object_def
  | function_def
  | function_call
  | match_tree
  | variable_declaration
  | variable_assignment
  | variable_access
  | object_method_assignment
  | contextual_variable_access
  | function_return_value
  | function_component_call
}

// Imports and exports in modules.
import = { "import" ~ "{" ~ (","? ~ IDENT ~ ("as" ~ IDENT)?)+ ~ "}" ~ "from" ~ string }
export = { "export" ~ expression }

// Variables.
variable_declaration       =  { ("var" | "const") ~ IDENT ~ (":" ~ elp_type)? }
variable_assignment        =  { variable_declaration ~ value_assignment }
value_assignment           =  { "=" ~ expression }
variable_access            = _{ (POINTER | REFERENCE)? ~ IDENT ~ ("." ~ (IDENT | function_call)*)? }
contextual_variable_access =  { "." ~ IDENT }

// Programming type info.
elp_type    = { IDENT ~ elp_generic? }
elp_generic = { "<" ~ elp_type ~ ("," ~ elp_type)* ~ ">" }
enum        = { "enum" ~ IDENT ~ "{" ~ (enum_member ~ ("," ~ enum_member)* ~ ","?)? ~ "}" }
enum_member = { "." ~ IDENT ~ ("(" ~ elp_type ~ ("," ~ elp_type)* ~ ")")? }

// Functions.
function_def            = { "fn" ~ (IDENT ~ ("." ~ IDENT)*) ~ function_arguments? ~ function_return_type? ~ block }
function_return_type    = { "->" ~ elp_type }
function_arguments      = { "(" ~ (SELF ~ ","?)? ~ (function_argument ~ ("," ~ function_argument)*)? ~ ")" }
function_argument       = { IDENT ~ elp_type }
function_component_call = { function_call ~ block }
function_call           = { (variable_access | contextual_variable_access) ~ elp_generic? ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
function_return_value   = { RETURN ~ expression }

// Objects.
object_def               = { "object" ~ IDENT ~ object_implements? ~ "{" ~ (object_member ~ ("," ~ object_member)* ~ ","?)? ~ "}" }
object_implements        = { IMPLEMENTS ~ elp_type ~ ("," ~ elp_type)* }
object_member            = { "." ~ IDENT ~ object_key_type? ~ object_key_default_value? ~ object_key_tags? }
object_key_type          = { elp_type }
object_key_default_value = { "=" ~ expression }
object_key_tags          = { "`" ~ IDENT ~ ":" ~ string ~ "`" }
object_method_assignment = { "." ~ IDENT ~ value_assignment }

// Matches.
match_tree       = { "match" ~ (variable_access | contextual_variable_access | function_call) ~ "{" ~ match_arm+ ~ "}" }
match_arm        = { (variable_access | contextual_variable_access | match_range | function_call) ~ "->" ~ (block | expression) ~ "," }
match_rangeables = { (string | number | variable_access) }
match_range      = { (match_rangeables | (".." ~ match_rangeables?) | (match_rangeables ~ ".." ~ match_rangeables?))+ }

// Groups of expressions.
block = { "{" ~ expression* ~ "}" }

// Meta programming tooling.
macro = { "@" ~ IDENT ~ ("(" ~ elp_type ~ ")")? }

// helpers.
string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char* }
char   =  {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
number = @{
    "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) ~ ("." ~ ASCII_DIGIT+)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

// Lexer tokens
IDENT      = @{ !number ~ !KEYWORD ~ (ASCII_ALPHANUMERIC+ | "_" | "\"" ~ inner ~ "\"")+ }
SELF       =  { "self" }
RETURN     =  { "return" }
REFERENCE  =  { "&" }
POINTER    =  { "*" }
IMPLEMENTS =  { "implements" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
KEYWORD    = _{ "import" | "export" | "enum" | "object" | "fn" | "var" | "const" | "object" }
