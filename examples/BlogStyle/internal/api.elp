// Imports tree shake and only import the desired exports of a module.
import { Error } from "elp"
import { Either } from "elp/types"
import { Reactive } from "elp/app"
import { Fetch, FetchError } from "elp/net"
import { UUID } from "elp/uuid"
import { parse as parseJSON, JSONError } from "elp/data/json"

// Enums take types which are used in pattern matching.
export enum ApiErrorType {
	.SERVER(Optional<string>)
	.USER(Optional<string>)
	.UNKNOWN(Optional<string>)
}

// An exported (module) object with the name Content,
// objects can define their default values and types are inferred
// or just define their type. Note the assignment and type declarations.
export object Content implements From<JSON> {
    .id		= UUID.v4() `json: "id"`

    .title  string		`json: "title"`
    .body   string		`json: "body"`
}

fn Content.fromJSON(json JSON) -> Either<Content, JSONError> {
	var out Content

	return parseJSON(json, &out)
}

// Objects can implement multiple interfaces. Interfaces don't influence the runtime,
// they are a compile time and static analysis tool. Note the generics syntax here which
// specializes the Interface to a type. You could implement From<Error>, From<int8>, From<string>, etc
export object ApiError implements Error, From<FetchError> {
	.type ApiErrorType
}

// Note this function implementation 
fn ApiError.new(type ApiErrorType) {
	.type = type
}

// Define methods on the object. self here denotes that it is an instance method,
// the .toString method is a requirement of the Error interface.
fn ApiError.toString(self) -> String {
    return .message
}

// This method is a static method as it doesn't take a self parameter and returns an instance.
fn ApiError.from(err FetchError) -> ApiError {
	return match err.responseCode {
		400..499 -> ApiError.new(.USER(err.toString()))
		500..599 -> ApiError.new(.SERVER(err.toString()))
		.. -> ApiError.new(.UNKNOWN(err.toString()))
	}
}

// This function returns a tagged enum called Either, which is a lot like a
// Rust Result<>.
export fn getBlogPost(id: string) -> Either<Content, ApiError> {
    return match Fetch.Get<Content, ApiError>("https://jsonplaceholder.typicode.com/posts/{id}") {
		Error(err) -> ApiError.from(err),
		Response(postJSON) -> Content.fromJSON(postJSON)
	}
}

// vim: ft=kotlin
